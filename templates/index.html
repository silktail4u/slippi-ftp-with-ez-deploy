<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>sharlots Slippi FTP Server</title>
    <style type="text/css">
        i.icon {
            display: block;
            height: 16px;
            width: 16px;
        }

        table {
            border-collapse: collapse; 
        }

        tr {
            border: none;
        }

        table tr {
            white-space: nowrap;
        }

        td.perms {}

        td.file-size {
            /* text-align: right; */
            /* padding-left: 1em; */
        }

        td.display-name {
            /* padding-left: 1em; */
        }

        td.game-info {
            /* padding-left: 1em; */
            font-size: 0.95em;
            color: black;
            text-align: end;
        }

        .stock-icons {
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .stock-icon-img {
            height: 16px;
            width: 16px;
            vertical-align: middle;
        }

        .perish {
            opacity: 0.5;
        }

        .player-info {
            display: inline-block;
        }

        i.icon-_blank {
            background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAWBJREFUeNqEUj1LxEAQnd1MVA4lyIEWx6UIKEGUExGsbC3tLfwJ/hT/g7VlCnubqxXBwg/Q4hQP/LhKL5nZuBsvuGfW5MGyuzM7jzdvVuR5DgYnZ+f99ai7Vt5t9K9unu4HLweI3qWYxI6PDosdy0fhcntxO44CcOBzPA7mfEyuHwf7ntQk4jcnywOxIlfxOCNYaLVgb6cXbkTdhJXq2SIlNMC0xIqhHczDbi8OVzpLSUa0WebRfmigLHqj1EcPZnwf7gbDIrYVRyEinurj6jTBHyI7pqVrFQqEbt6TEmZ9v1NRAJNC1xTYxIQh/MmRUlmFQE3qWOW1nqB2TWk1/3tgJV0waVvkFIEeZbHq4ElyKzAmEXOx6gnEVJuWBzmkRJBRPYGZBDsVaOlpSgVJE2yVaAe/0kx/3azBRO0VsbMFZE3CDSZKweZfYIVg+DZ6v7h9GDVOwZPw/PoxKu/fAgwALbDAXf7DdQkAAAAASUVORK5CYII=");
        }

        i.icon-_page {
            background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmhJREFUeNpsUztv01AYPfdhOy/XTZ80VV1VoCqlA2zQqUgwMEErWBALv4GJDfEDmOEHsFTqVCTExAiiSI2QEKJKESVFFBWo04TESRzfy2c7LY/kLtf2d8+555zvM9NaI1ora5svby9OnbUEBxgDlIKiWjXQeLy19/X17sEtcPY2rtHS96/Hu0RvXXLz+cUzM87zShsI29DpHCYt4E6Box4IZzTnbDx7V74GjhOSfwgE0H2638K9h08A3iHGVbjTw7g6YmAyw/BgecHNGGJjvfQhIfmfIFDAXJpjuugi7djIFVI4P0plctgJQ0xnFe5eOO02OwEp2VkhSCnC8WOCdqgwnzFx4/IyppwRVN+XYXsecqZA1pB48ekAnw9/4GZx3L04N/GoTwEjX4cNH5vlPfjtAIYp8cWrQutxrC5Mod3VsXVTMFSqtaE+gl9dhaUxE2tXZiF7nYiiatJ3v5s8R/1yOCNLOuwjkELiTbmC9dJHpIaGASsDkoFQGJQwHWMcHWJYOmUj1OjvQotuytt5nHMLEGkCyx6QU384jwkUAd2sxJbS/QShZtg/8rHzzQOzSaFhxQrA6YgQMQHojCUlgnCAAvKFBoXXaHfArSCZDE0gyWJgFIKmvUFKO4MUNIk2a4+hODtDUVuJ/J732AKS6ZtImdTyAQQB3bZN8l9t75IFh0JMUdVKsohsUPqRgnka0tYgggYpCHkKGTsHI5NOMojB4iTICCepvX53AIEfQta1iUCmoTiBmdEri2RgddKFhuJoqb/af/yw/d3zTNM6UkaOfis62aUgddAbnz+rXuPY+Vnzjt9/CzAAbmLjCrfBiRgAAAAASUVORK5CYII=");
        }
        #fileList {
            display: flex;
            max-width: 100vw;
            justify-content: space-between;
        }
        tbody {
            width: auto;
            /* overflow: scroll; */
            flex: 1;
            padding: 0 20px 0 20px;
        }
        tr {
            display: flex;
            /* flex-direction: column; */
            justify-content: space-between;
        }
        .file-info {
            display: flex;
            flex-direction: column;
        }
        img {
            vertical-align: middle;
        }
        .set-header {
            background: #cfc;
            font-weight: bold;
            font-size: 1.05em;
            padding: 4px 8px;
            width: 100%;
            text-align: center;
            border-top: 2px solid black;
            border-left: 2px solid black;
            border-right: 2px solid black;
        }
        .set-row {
            border-left: 2px solid black;
            border-right: 2px solid black;
            border-top: none;
            border-bottom: none;
        }
        .set-row.last-in-set {
            border-bottom: 2px solid black;
            margin-bottom: 10px;
        }
        .ignored > * {
            font-style: italic;
            opacity: 0.5;
        }
    </style>
</head>

<body>
    <h1>sharlots Slippi FTP Server</h1>
    <button id="exportReplayManagerBtn">Export selected to <img alt="Replay Manager" src="/assets/replay-manager.png" width="18" height="18"> Replay Manager</button>
    <table id="fileList"></table>
    <table id="errorFileList"></table>
    <br>
    <address id="footer">sharlots-slippi-ftp-server running @ 127.0.0.1:9876</address>
    <script>
        // --- Timer ticking logic ---
        let timerTickers = {};
        function parseTimerString(timerStr) {
            // Expects mm:ss.SS
            if (!timerStr || timerStr === 'Unknown') return null;
            const match = timerStr.match(/(\d+):(\d+)\.(\d+)/);
            if (!match) return null;
            return {
                minutes: parseInt(match[1], 10),
                seconds: parseInt(match[2], 10),
                centiseconds: parseInt(match[3], 10)
            };
        }
        function timerToCentiseconds(timer) {
            return timer.minutes * 60 * 100 + timer.seconds * 100 + timer.centiseconds;
        }
        function centisecondsToTimer(cs) {
            let totalSeconds = Math.floor(cs / 100);
            let minutes = Math.floor(totalSeconds / 60);
            let seconds = totalSeconds % 60;
            let centiseconds = cs % 100;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
        }
        function startTimerTicker(timerKey, timerStr) {
            if (!timerStr || timerStr === 'Unknown') return;
            let timer = parseTimerString(timerStr);
            if (!timer) return;
            let cs = timerToCentiseconds(timer);
            if (timerTickers[timerKey]) {
                const diff = Math.abs(timerTickers[timerKey].cs - cs);
                if (diff > 64) {
                    timerTickers[timerKey].cs = cs;
                    timerTickers[timerKey].reset = true;
                }
                timerTickers[timerKey].stopped = false;
                return;
            }
            let ticker = { cs, reset: false, stopped: false };
            timerTickers[timerKey] = ticker;
            function tick() {
                if (ticker.stopped) return;
                if (ticker.reset) {
                    ticker.reset = false;
                    cs = ticker.cs;
                }
                if (cs > 0) {
                    cs--;
                    const el = document.querySelector(`#timer-${timerKey}`);
                    if (el) el.textContent = centisecondsToTimer(cs);
                    ticker.cs = cs;
                }
                setTimeout(tick, 1000/60);
            }
            tick();
        }

        function getReplayCheckboxId(filename) {
            return 'replay-checkbox-' + filename.replace(/[^a-zA-Z0-9_\-]/g, '_');
        }

        function renderReplayRow(replay, rowIdx, isLast) {
            const isActive = replay.is_active_transfer;
            const timerKey = replay.filename.replace(/[^a-zA-Z0-9_\-]/g, '_');
            // Stop timer if it exists and is no longer active
            if (!isActive && timerTickers[timerKey]) {
                timerTickers[timerKey].stopped = true;
                delete timerTickers[timerKey];
            }
            // Format file size
            let sizeStr;
            if (replay.size_bytes < 1024) {
                sizeStr = replay.size_bytes + 'B';
            } else if (replay.size_bytes < 1024 * 1024) {
                sizeStr = Math.round(replay.size_bytes / 1024 * 10) / 10 + 'k';
            } else {
                sizeStr = Math.round(replay.size_bytes / (1024 * 1024) * 10) / 10 + 'M';
            }
            const date = new Date(replay.created_time);
            // Format date to match nginx style
            const dateStr = date.toLocaleDateString('en-GB', {
                day: '2-digit',
                month: 'short',
                year: 'numeric'
            }) + ' ' + date.toLocaleTimeString('en-GB', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            let gameInfoHtml = '';
            let watchOptionsHtml = '';
            let spectatormodeLink = '';
            let slippiLauncherForkLink = '';
            let slippiLauncherLink = '';
            let slippiTvLink = '';
            let slippilabLink = '';
            let ignoreForScore = false;
            if (!replay.is_active_transfer && replay.game_info && replay.game_info.players && replay.game_info.players.length >= 2) {
                const p0 = replay.game_info.players[0];
                const p1 = replay.game_info.players[1];
                if (typeof p0.stock_count === 'number' && typeof p1.stock_count === 'number') {
                    if (p0.stock_count > 1 && p1.stock_count > 1) {
                        ignoreForScore = true;
                    }
                }
            }
            if (replay.game_info && !replay.game_info.error) {
                const stage = replay.game_info.stage_name || '';
                const players = replay.game_info.players || [];
                const charDisplayNames = {
                    'captain_falcon': 'Captain Falcon',
                    'donkey_kong': 'Donkey Kong',
                    'fox': 'Fox',
                    'game_and_watch': 'Mr. Game & Watch',
                    'kirby': 'Kirby',
                    'bowser': 'Bowser',
                    'link': 'Link',
                    'luigi': 'Luigi',
                    'mario': 'Mario',
                    'marth': 'Marth',
                    'mewtwo': 'Mewtwo',
                    'ness': 'Ness',
                    'peach': 'Peach',
                    'pikachu': 'Pikachu',
                    'ice_climbers': 'Ice Climbers',
                    'jigglypuff': 'Jigglypuff',
                    'samus': 'Samus',
                    'yoshi': 'Yoshi',
                    'zelda': 'Zelda',
                    'sheik': 'Sheik',
                    'falco': 'Falco',
                    'young_link': 'Young Link',
                    'dr_mario': 'Dr. Mario',
                    'roy': 'Roy',
                    'pichu': 'Pichu',
                    'ganondorf': 'Ganondorf',
                    'master_hand': 'Master Hand',
                    'wireframe_male': 'Wireframe Male',
                    'wireframe_female': 'Wireframe Female',
                    'giga_bowser': 'Giga Bowser',
                    'crazy_hand': 'Crazy Hand',
                    'sandbag': 'Sandbag',
                    'popo': 'Popo',
                    'none': 'None'
                };
                let timerHtml = '';
                if (replay.game_info.timer && replay.game_info.timer !== 'Unknown') {
                    timerHtml = `<div><b><span class='timer-value' id='timer-${timerKey}'>${replay.game_info.timer}</span></b></div>`;
                    if (isActive) {
                        setTimeout(() => startTimerTicker(timerKey, replay.game_info.timer), 0);
                    }
                }
                if (isActive) {
                    slippiLauncherForkLink = `<div><a href="slippi-mirror://play?path=https://sharlot.memes.nz/slp-files/${replay.filename}&mirror=1">Watch with <img alt="Slippi Launcher" src="/assets/slippilauncher.png" width="18" height="18"> Slippi Launcher (fork)</a></div>`;
                }
                if (isActive && replay.game_info.spectatormode_stream_id) {
                    spectatormodeLink = `<div><a href="https://spectatormode.tv/?watch=${replay.game_info.spectatormode_stream_id}">Watch on spectatormode.tv</a></div>`;
                }
                if (isActive) {
                    slippiTvLink = `<div><a href="slippi-tv://watch?code=${replay.game_info.console_name.toUpperCase()}">Watch with <img alt="SlippiTV" src="/assets/slippitv.png" width="18" height="18"> SlippiTV</a></div>`;
                }
                if (!isActive) {
                    slippiLauncherLink = `<div><a href="slippi://play?path=https://sharlot.memes.nz/slp-files/${replay.filename}">Watch with <img alt="Slippi Launcher" src="/assets/slippilauncher.png" width="18" height="18"> Slippi Launcher</a></div>`;
                }
                if (!isActive && replay.game_info.slippilab_link) {
                    slippilabLink = `<div><a href="${replay.game_info.slippilab_link}">Watch on <img alt="Slippi Lab" src="/assets/slippilab.png" width="18" height="18"> Slippi Lab</a></div>`;
                }
                watchOptionsHtml = `${slippiLauncherForkLink}${spectatormodeLink}${slippiTvLink}${slippiLauncherLink}${slippilabLink}`;
                let consoleHtml = '';
                gameInfoHtml = `<div><b>${stage}</b></div>` + timerHtml + '<div>' +
                    players.map(p => {
                        let stocks = '';
                        for (let i = 0; i < p.stock_count; ++i) {
                            stocks += `<img class='stock-icon-img' src='${p.icon}' alt='${p.character}'>`;
                        }
                        if (stocks == 0) {
                            stocks += `<img class='stock-icon-img perish' src='${p.icon}' alt='${p.character}'>`;
                        }
                        const displayName = charDisplayNames[p.character] || p.character.replace(/_/g, ' ');
                        return `<span class='player-info'>${stocks} <span title='${p.character}'>${displayName}</span></span>`;
                    }).join(' vs ') + '</div>';
            } else if (replay.game_info && replay.game_info.error) {
                gameInfoHtml = `<div style='color:#a00;font-size:0.9em;'>${replay.game_info.error}</div>`;
            }
            const rowBg = (rowIdx % 2 === 0) ? '#f2f2f2' : '#ffffff';
            let className = 'set-row';
            if (isLast) className += ' last-in-set';
            if (ignoreForScore) className += ' ignored';
            const checkboxId = getReplayCheckboxId(replay.filename);
            const replayUrl = `https://sharlot.memes.nz/slp-files/${replay.filename}`;
            let checkboxHtml = `<input type="checkbox" class="replay-checkbox" id="${checkboxId}" data-url="${replayUrl}" style="margin-right:6px;vertical-align:middle;">`;
            const rowId = getReplayRowId(replay);
            return `
                <tr class="${className}" style="background:${rowBg}" id="${rowId}">
                    <td>
                        <div class="file-info">
                            <span class="last-modified">${dateStr}</span>
                            <span class="file-size"><code>${sizeStr}</code></span>
                            <span class="display-name">
                                ${checkboxHtml}
                                ${isActive ? '<span style="color:#d00;font-size:1.2em;vertical-align:middle;">ðŸ”´</span> ' : ''}
                                <a href="https://sharlot.memes.nz/slp-files/${replay.filename}">${replay.filename}</a>
                                ${isActive ? ' <span style="color:#d00;font-weight:bold;">(live)</span>' : ''}
                            </span>
                            ${watchOptionsHtml}              
                        </div>
                    </td>
                    <td class="game-info">
                        ${gameInfoHtml}
                    </td>
                </tr>
            `;
        }
        function getSelectedReplayUrls() {
            const checkboxes = document.querySelectorAll('.replay-checkbox');
            const urls = [];
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    urls.push(cb.getAttribute('data-url'));
                }
            });
            return urls;
        }

        document.addEventListener('DOMContentLoaded', function() {
            const exportBtn = document.getElementById('exportReplayManagerBtn');
            exportBtn.addEventListener('click', function() {
                const urls = getSelectedReplayUrls();
                if (urls.length === 0) {
                    alert('Please select at least one replay to export.');
                    return;
                }
                const url = 'replay-manager://load?path=' + urls.join(';');
                location.href = url;
            });
        });

        function getCheckedReplayUrls() {
            const checked = [];
            document.querySelectorAll('.replay-checkbox:checked').forEach(cb => {
                checked.push(cb.getAttribute('data-url'));
            });
            return checked;
        }

        function restoreCheckedReplayUrls(urls) {
            urls.forEach(url => {
                const cb = document.querySelector('.replay-checkbox[data-url="' + url.replace(/(["'\\])/g, '\\$1') + '"]');
                if (cb) cb.checked = true;
            });
        }


        let lastReplayData = null;
        function deepEqual(a, b) {
            if (a === b) return true;
            if (typeof a !== typeof b) return false;
            if (typeof a !== 'object' || a === null || b === null) return false;
            if (Array.isArray(a)) {
                if (!Array.isArray(b) || a.length !== b.length) return false;
                for (let i = 0; i < a.length; ++i) if (!deepEqual(a[i], b[i])) return false;
                return true;
            }
            const keysA = Object.keys(a), keysB = Object.keys(b);
            if (keysA.length !== keysB.length) return false;
            for (const k of keysA) if (!deepEqual(a[k], b[k])) return false;
            return true;
        }

        function getReplayRowId(replay) {
            return 'replay-row-' + replay.filename.replace(/[^a-zA-Z0-9_\-]/g, '_');
        }

        async function loadReplays() {
            const prevChecked = getCheckedReplayUrls();
            try {
                const response = await fetch('/api/replays');
                const data = await response.json();
                // Only update if data actually changed
                if (lastReplayData && deepEqual(data, lastReplayData)) {
                    // Only update timer values for live games
                    document.querySelectorAll('.timer-value').forEach(el => {
                        const id = el.id;
                        if (id && timerTickers[id.replace('timer-', '')]) {
                            // Timer ticker already updates value
                        }
                    });
                    return;
                }
                lastReplayData = JSON.parse(JSON.stringify(data));
                const listEl = document.getElementById('fileList');
                const errorListEl = document.getElementById('errorFileList');
                if (data.replays.length === 0) {
                    listEl.innerHTML = '<tr><td colspan="6">No files found</td></tr>';
                    return;
                }
                // Sort replays from newest to oldest by created_time
                const sortedReplays = data.replays.slice().sort((a, b) => {
                    const dateA = new Date(a.created_time);
                    const dateB = new Date(b.created_time);
                    return dateB - dateA;
                });

                // Group replays by console
                const grouped = {};
                const invalidConsoleGroup = [];
                for (const replay of sortedReplays) {
                    let consoleName = (replay.game_info && replay.game_info.console_name) ? replay.game_info.console_name : 'Unknown Console';
                    if (consoleName == 'Unknown Console') {
                        invalidConsoleGroup.push(replay);
                        continue;
                    }
                    if (!grouped[consoleName]) grouped[consoleName] = [];
                    grouped[consoleName].push(replay);
                }

                function clusterReplays(replays) {
                    function getWinner(p0, p1) {
                        if (typeof p0.stock_count === 'number' && typeof p1.stock_count === 'number') {
                            if (p0.stock_count > p1.stock_count) return 0;
                            if (p1.stock_count > p0.stock_count) return 1;
                            // Tie: use lower percent as winner
                            if (
                                typeof p0.percent === 'number' &&
                                typeof p1.percent === 'number'
                            ) {
                                if (p0.percent < p1.percent) return 0;
                                if (p1.percent < p0.percent) return 1;
                            }
                        }
                        return -1; // tie
                    }
                    // Work on a copy sorted oldest to newest
                    const chronological = replays.slice().sort((a, b) => {
                        const dateA = new Date(a.created_time);
                        const dateB = new Date(b.created_time);
                        return dateA - dateB;
                    });
                    const clusters = [];
                    let currentCluster = null;
                    let lastReplay = null;
                    for (let i = 0; i < chronological.length; ++i) {
                        const replay = chronological[i];
                        let isNewSet = false;
                        // Track score for split-on-3 logic
                        let scoreA = currentCluster ? currentCluster.score[0] : 0;
                        let scoreB = currentCluster ? currentCluster.score[1] : 0;
                        if (!lastReplay) {
                            isNewSet = true;
                        } else {
                            // Use game end time for set gap
                            const lastStart = new Date(lastReplay.created_time).getTime();
                            let lastDurationMs = 0;
                            if (lastReplay.game_info && typeof lastReplay.game_info.frame_count === 'number') {
                                lastDurationMs = (lastReplay.game_info.frame_count / 60) * 1000;
                            }
                            const lastEnd = lastStart + lastDurationMs;
                            const thisStart = new Date(replay.created_time).getTime();
                            const gapMs = thisStart - lastEnd;
                            const hardGap = 3 * 60 * 1000; // 3 min
                            const softGap = 1 * 60 * 1000; // 1 min
                            const lastPlayers = (lastReplay.game_info && lastReplay.game_info.players) || [];
                            const thisPlayers = (replay.game_info && replay.game_info.players) || [];
                            // Always split if gap > hardGap
                            if (gapMs > hardGap) {
                                isNewSet = true;
                            } else if (gapMs > softGap) {
                                // If gap > softGap, split if any port/character/costume changes
                                if (lastPlayers.length !== thisPlayers.length) {
                                    isNewSet = true;
                                } else {
                                    let anyChange = false;
                                    for (let j = 0; j < lastPlayers.length; ++j) {
                                        if (lastPlayers[j].port !== thisPlayers[j].port ||
                                            lastPlayers[j].character_id !== thisPlayers[j].character_id ||
                                            lastPlayers[j].costume !== thisPlayers[j].costume) {
                                            anyChange = true;
                                            break;
                                        }
                                    }
                                    if (anyChange) isNewSet = true;
                                }
                            } else {
                                // If gap <= softGap, split only on port swap or both character/costume swap
                                if (lastPlayers.length !== thisPlayers.length) {
                                    isNewSet = true;
                                } else {
                                    // Ports swap
                                    const lastPorts = lastPlayers.map(p => p.port).join(',');
                                    const thisPorts = thisPlayers.map(p => p.port).join(',');
                                    if (lastPorts !== thisPorts) {
                                        isNewSet = true;
                                    } else {
                                        // Both characters/costumes swap
                                        let allSwap = true;
                                        for (let j = 0; j < lastPlayers.length; ++j) {
                                            if (lastPlayers[j].character_id === thisPlayers[j].character_id && lastPlayers[j].costume === thisPlayers[j].costume) {
                                                allSwap = false;
                                                break;
                                            }
                                        }
                                        if (allSwap) isNewSet = true;
                                    }
                                }
                            }
                        }
                        // Score calculation: winner is player with more stocks (if available and both <=1)
                        let ignoreForScore = false;
                        if (replay.game_info && replay.game_info.players && replay.game_info.players.length >= 2) {
                            const p0 = replay.game_info.players[0];
                            const p1 = replay.game_info.players[1];
                            if (typeof p0.stock_count === 'number' && typeof p1.stock_count === 'number') {
                                if (p0.stock_count > 1 && p1.stock_count > 1) {
                                    ignoreForScore = true;
                                }
                            }
                        }
                        // Update score for split-on-3 logic
                        let nextScoreA = scoreA, nextScoreB = scoreB;
                        if (
                            currentCluster &&
                            !replay.is_active_transfer &&
                            replay.game_info &&
                            replay.game_info.players &&
                            replay.game_info.players.length >= 2 &&
                            !ignoreForScore
                        ) {
                            const p0 = replay.game_info.players[0];
                            const p1 = replay.game_info.players[1];
                            const winner = getWinner(p0, p1);
                            if (winner === 0) nextScoreA++;
                            else if (winner === 1) nextScoreB++;
                        }
                        // Split if either player reaches 4
                        if (!isNewSet && (nextScoreA === 4 || nextScoreB === 4)) {
                            isNewSet = true;
                        }
                        if (isNewSet) {
                            if (currentCluster) clusters.push(currentCluster);
                            currentCluster = { replays: [], score: [0, 0] };
                            scoreA = 0;
                            scoreB = 0;
                            nextScoreA = 0;
                            nextScoreB = 0;
                        }
                        // Actually update the score in the cluster
                        if (currentCluster && replay.game_info && replay.game_info.players && replay.game_info.players.length >= 2 && !ignoreForScore && !replay.is_active_transfer) {
                            const p0 = replay.game_info.players[0];
                            const p1 = replay.game_info.players[1];
                            const winner = getWinner(p0, p1);
                            if (winner === 0) currentCluster.score[0]++;
                            else if (winner === 1) currentCluster.score[1]++;
                        }
                        if (currentCluster) currentCluster.replays.push(replay);
                        lastReplay = replay;
                    }
                    if (currentCluster) clusters.push(currentCluster);
                    // Reverse clusters and each cluster's replays for newest-to-oldest display
                    clusters.reverse();
                    for (const cluster of clusters) {
                        cluster.replays.reverse();
                    }
                    return clusters;
                }

                let rowIdx = 0;
                let html = '';
                const sortedConsoleNames = Object.keys(grouped).sort((a, b) => a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'}));
                let allReplayIds = new Set();
                for (const consoleName of sortedConsoleNames) {
                    const replays = grouped[consoleName];
                    const clusters = clusterReplays(replays);
                    html += `<tbody>`;
                    html += `<tr><td colspan='2' style='background:#eee;font-weight:bold;font-size:1.1em;width: 100%;'>Console: ${consoleName}</td></tr>`;
                    for (let clusterIdx = 0; clusterIdx < clusters.length; ++clusterIdx) {
                        const cluster = clusters[clusterIdx];
                        let playerChars = [[], []];
                        let seenChars = [new Set(), new Set()];
                        for (const replay of cluster.replays) {
                            if (replay.game_info && replay.game_info.players && replay.game_info.players.length >= 2) {
                                for (let p = 0; p < 2; ++p) {
                                    const char = replay.game_info.players[p].character;
                                    const icon = replay.game_info.players[p].icon;
                                    if (char && !seenChars[p].has(char)) {
                                        seenChars[p].add(char);
                                        playerChars[p].push({icon, name: char});
                                    }
                                }
                            }
                        }
                        const scoreA = cluster.score[0];
                        const scoreB = cluster.score[1];
                        function renderIcons(arr) {
                            return arr.map(pc => `<img class='stock-icon-img' src='${pc.icon}' alt='${pc.name}'>`).join(' ');
                        }
                        let leftIcons = renderIcons(playerChars[0]);
                        let rightIcons = renderIcons(playerChars[1]);
                        let scoreDisplay;
                        if (scoreA >= scoreB) {
                            scoreDisplay = `${leftIcons} ${scoreA} - ${scoreB} ${rightIcons}`;
                        } else {
                            scoreDisplay = `${rightIcons} ${scoreB} - ${scoreA} ${leftIcons}`;
                        }
                        // Add export set button
                        const setReplayUrls = cluster.replays.map(r => `https://sharlot.memes.nz/slp-files/${r.filename}`).join(';');
                        const setExportBtnId = `export-set-btn-${consoleName.replace(/[^a-zA-Z0-9_\-]/g, '_')}-${clusterIdx}`;
                        html += `<tr><td colspan='2' class='set-header' style='display:flex;align-items:center;justify-content:space-between;'>
                            <span>Score: ${scoreDisplay}</span>
                            <button class="export-set-btn" id="${setExportBtnId}" data-urls="${setReplayUrls}" style="margin-left:8px;">Export Set to <img alt="Replay Manager" src="/assets/replay-manager.png" width="18" height="18"> Replay Manager</button>
                        </td></tr>`;
                        for (let i = 0; i < cluster.replays.length; ++i) {
                            const replay = cluster.replays[i];
                            const isLast = i === cluster.replays.length - 1;
                            html += renderReplayRow(replay, rowIdx, isLast);
                            allReplayIds.add(getReplayRowId(replay));
                            rowIdx++;
                        }
                    }
                    html += `</tbody>`;
                }
                listEl.innerHTML = html;
                // For Unknown Console, wrap replays in a single cluster if any
                let errorHtml = '';
                let errorRowIdx = 0;
                if (invalidConsoleGroup.length > 0) {
                    const errorClusters = [{ replays: invalidConsoleGroup, score: [0, 0] }];
                    for (const cluster of errorClusters) {
                        errorHtml += `<tbody><tr><td colspan='2' style='background:#eee;font-weight:bold;font-size:1.1em;width: 100%;'>Console: Unknown Console</td></tr>`;
                        for (let i = 0; i < cluster.replays.length; ++i) {
                            const replay = cluster.replays[i];
                            errorHtml += renderReplayRow(replay, i, i === cluster.replays.length - 1);
                            allReplayIds.add(getReplayRowId(replay));
                        }
                        errorHtml += `</tbody>`;
                    }
                }
                errorListEl.innerHTML = errorHtml;
                restoreCheckedReplayUrls(prevChecked);

                document.querySelectorAll('.export-set-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        const urls = btn.getAttribute('data-urls');
                        if (!urls) return;
                        const url = 'replay-manager://load?path=' + urls;
                        location.href = url;
                        e.stopPropagation();
                    });
                });
            } catch (error) {
                console.error('Failed to load replays:', error);
                document.getElementById('fileList').innerHTML = '<tr><td colspan="6">Error loading files</td></tr>';
            }
        }
        loadReplays();
        setInterval(loadReplays, 1000);
    </script>
</body>

</html>
